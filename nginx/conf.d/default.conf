# /etc/nginx/conf.d/wildcard-proxy.conf
# This file will be included by the default nginx.conf

# Define service-specific ports
# map $service $upstream_port {
#     default     80;    # Default port if not specified
#     # app         3000;  # Your service-specific ports
#     blog        8080;
#     api         8000;
#     # Add more service:port mappings as needed
# }

map $subdomain $root_path {
    default     "/var/www/public";    # Default root (Laravel)
    blog        "/var/www/blog/public";
    api         "/var/www/api/public";
    # Add more service-specific root paths as needed
}

map $subdomain $upstream_port {
    default     80;     
    blog        8080;    
    api         8000;    
    # Add more service:port mappings as needed
}

# Wildcard server block
server {
    listen 80;
    # listen [::]:80;
    server_name ~^(?<service>.+)\.xurl\.fyi$;

    return 301 https://$host$request_uri;
 
}

server {
    listen 80;
    # listen [::]:80;
    server_name xurl.fyi www.xurl.fyi;  # Your domain without wildcard subdomain
    return 301 https://$host$request_uri;

}


server {
    listen 443 ssl;
    # listen [::]:443 ssl;

    # http2;
    server_name xurl.fyi;

    ssl_certificate /etc/letsencrypt/live/xurl.fyi.fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/xurl.fyi.key;

    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;

  


    # map $http_upgrade $connection_upgrade {
    #     default upgrade;
    #     ''      close;
    # }
    # # Serve static files directly
    # location /static/ {
    #     root /var/www/;
    # }

    # Proxy to app
    location / {
       proxy_pass http://app:3000;
        # Preserve client info
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Host $host;

        # WebSockets support
        proxy_http_version 1.1;
        # proxy_set_header Upgrade $http_upgrade;
        # proxy_set_header Connection $connection_upgrade;
        proxy_buffering off;

        # Timeouts & upstream error handling
        proxy_connect_timeout 5s;
        proxy_next_upstream error timeout http_500 http_502 http_503 http_504;

        # Show maintenance page if backend is down
        error_page 502 503 504 /maintenance.html;
    }
    # Serve static files like CSS, JS, fonts from /var/www/html/static
    location /css/ {
        alias /usr/share/nginx/html/app1/static/css/;
        access_log off;
        expires max;
    }

    location /libs/ {
        alias /usr/share/nginx/html/app1/static/libs/;
        access_log off;
        expires max;
    }

    location /scripts/ {
        alias /usr/share/nginx/html/app1/static/scripts/;
        access_log off;
        expires max;
    }

    location /fonts/ {
        alias /usr/share/nginx/html/app1/static/fonts/;
        access_log off;
        expires max;
    }
    # Serve images
    location /images/ {
        alias /usr/share/nginx/html/app1/static/images/;  # Use alias for image directory
        access_log off;
        # autoindex on;
        expires 7d;
        add_header Cache-Control "public, max-age=604800";
    }

    # Ensure correct MIME types for images
    # location ~* \.(png|jpg|jpeg|gif|webp|svg)$ {
    #     root /usr/share/nginx/html/app1/static;  # Correct path to where your images are located
    #     expires 7d;
    #     add_header Cache-Control "public, max-age=604800";
    # }
    error_page 403 /403.html;
    error_page 404 /404.html;
    error_page 500 502 504 /50x.html;
    error_page 503 /maintenance.html;
    

    location = /403.html {
        alias /var/www/errors/403.html;
        internal;
    }

    location = /404.html {
        alias /var/www/errors/404.html;
        internal;
    }

    location = /50x.html {
        alias /var/www/errors/50x.html;
        internal;
    }

    # touch /var/www/html/maintenance.flag
    # rm /var/www/html/maintenance.flag


    if (-f /var/www/html/maintenance.flag) {
        return 503;
    }

    

    location = /maintenance.html {
        alias /var/www/errors/maintenance.html;
        internal;
    }

    # # Allow specific IPs to bypass maintenance mode
    # location / {
    #     allow 123.456.789.000;  # Replace with your IP
    #     deny all;
    # }
   
}



server {
    listen 443 ssl;
    # listen [::]:443 ssl;

    server_name ~^(?<service>.+)\.xurl\.fyi$;

    ssl_certificate /etc/letsencrypt/live/xurl.fyi.fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/xurl.fyi.key;

    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;


    # # Default backend container if container name is different from subdomain
    # set $backend "laravel_app";
    
    # # Change backend container dynamically
    # if ($subdomain = "blog") {
    #     set $backend "blog_app";
    # }
    # if ($subdomain = "api") {
    #     set $backend "api_app";
    # }
    # Ensure Nginx resolves container hostnames dynamically
    resolver 127.0.0.11 valid=10s; 

    # resolver 8.8.8.8 1.1.1.1 valid=10s;

    # Serve static files based on root path
    location ~* \.(jpg|jpeg|png|gif|ico|css|js|svg|woff|woff2|ttf|otf|eot|mp4|webm|ogg|mp3|wav|zip|pdf)$ {
        root $root_path;
        access_log off;
        expires max;
        add_header Cache-Control "public, max-age=31536000, immutable";
    }

    # Serve PHP requests through FPM if the service is Laravel-based
    location ~ \.php$ {
        include fastcgi_params;
        fastcgi_pass laravel_app:9000;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $root_path$fastcgi_script_name;
         # Increase timeout to handle slow PHP responses
        fastcgi_read_timeout 60s;

        # Handle errors gracefully
        # error_page 502 503 504 /maintenance.html;
    }

    location / {

        # Avoid sending PHP files to upstream
        try_files $uri $uri/ /index.php?$query_string;
        # Dynamic upstream configuration
        # set $upstream http://$service:$upstream_port;
        proxy_pass http://$service:$upstream_port;

        proxy_pass $upstream;

        # Basic proxy settings
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Handle container unavailability
        proxy_connect_timeout 5s;
        proxy_next_upstream error timeout http_500 http_502 http_503 http_504;
        # If Laravel is down, show maintenance page instead of failing
        # error_page 502 503 504 /maintenance.html;
    }

    location /api {
        
        proxy_pass http://$service:$upstream_port;
        
        # Pass headers correctly to the backend
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Only serve JSON errors when the API is actually down
        error_page 500 502 503 504 = /api-error.json;
        # error_page 500 = /api-500.json;
        # error_page 502 = /api-502.json;
        # error_page 503 = /api-503.json;
        # error_page 504 = /api-504.json;

    }

    error_page 403 /403.html;
    error_page 404 /404.html;
    error_page 500 502 504 /50x.html;
    error_page 503 /maintenance.html;
    

    location = /403.html {
        alias /var/www/errors/403.html;
        internal;
    }

    location = /404.html {
        alias /var/www/errors/404.html;
        internal;
    }

    location = /50x.html {
        alias /var/www/errors/50x.html;
        internal;
    }

    location = /maintenance.html {
        alias /var/www/errors/maintenance.html;
        internal;
    }


    location = /api-error.json {
        return 500 '{"message": "Service is temporarily unavailable"}';
        add_header Content-Type application/json;
    }

}